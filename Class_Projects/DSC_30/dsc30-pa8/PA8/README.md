# DSC 30 — PA8: Hash Tables, Collision Handling & Spell Checker (with Bloom Filter)

> Implement a **hash table** (separate chaining), explore **collision handling**, and build a **spell checker** that can run on either a HashTable or a **Bloom Filter**.

## Overview
This assignment has two parts:
1) **Hash Table implementation & tests** — build/verify core hash set operations; reason about collision handling strategies.  
2) **SpellChecker** — load a word dictionary and check an input text for misspellings; suggest corrections via single‑edit operations (replace/insert/delete/swap/insert‑space).

See the included prompt PDF for the original specification (if provided by your course handout).  

## Folder Contents
- `src/`
  - `KeyedSet.java` — common interface (insert/lookup) used by both data structures
  - `MyHashTable.java` — chained hash table implementation (rehash/stats/collisions)
  - `MyBloomFilter.java` — Bloom filter implementation (bit array + multiple hashes)
  - `MyHashTableTester.java` — primary unit tests for MyHashTable (JUnit)
  - `CollisionHandling.java` — worksheet helpers for linear/quadratic probing exercises
  - `SpellChecker.java` — CLI spell checker; toggles HashTable vs BloomFilter
  - `Samples/` — sample inputs, expected outputs, and toy dictionaries
    - `Input1.txt`, `Input2.txt`, `Input3.txt`
    - `Output1.txt`, `Output2.txt`, `Output3.txt`
    - `tiny.dict.txt`, `simple.dict.txt`, `long.dict.txt`
    - `relation.txt` — notes which input pairs with which dictionary
- `PA8.iml` — IDE metadata (IntelliJ)

## Dictionaries & Samples
- **Dictionaries**: plain‑text word lists, one word per line.  
- **Inputs**: text files whose tokens will be spell‑checked.  
- **Expected Outputs**: reference output for each corresponding input.  
- **Mapping** (from `Samples/relation.txt`):  
  - `Input1.txt` ↔ `tiny.dict.txt`  
  - `Input2.txt` ↔ `long.dict.txt`  
  - `Input3.txt` ↔ `long.dict.txt`

## SpellChecker Behavior (`SpellChecker`)
The driver loads a dictionary into either a **hash table** or a **Bloom filter**, then processes an input file **one token per line**, printing for each token:
- `"ok"` if the word exists in the dictionary; otherwise
- a comma‑separated list of **candidate corrections** generated by:
  - **Replace** one letter
  - **Insert** one letter
  - **Delete** one letter
  - **Swap** two adjacent letters
  - **Insert space** at one position (splitting into two valid words)

> Note: Bloom filters can yield **false positives** (reporting “ok” for some words that aren’t actually present).

## CLI Usage
```bash
# From the PA8/src directory
javac *.java

# Run SpellChecker
# args[0] = 0 → use MyHashTable; 1 → use MyBloomFilter
# args[1] = path to dictionary file
# args[2] = path to input file
java SpellChecker 0 Samples/tiny.dict.txt Samples/Input1.txt
java SpellChecker 1 Samples/long.dict.txt  Samples/Input3.txt
```

## Tests
- `MyHashTableTester.java` includes JUnit tests covering construction, insertion, lookup, resizing/rehashing, and error handling.  
- You can run tests from your IDE’s JUnit runner or via your build tool of choice.

## Notes
- Remove macOS artifacts (`.DS_Store`, `__MACOSX/`) if present in your checkout.  
- For large dictionaries, prefer running the Bloom filter mode to compare performance/behavior vs hash table.  
- `CollisionHandling.java` contains worksheet routines (static) to illustrate probing results; it is not part of the SpellChecker CLI.

## Quickstart (All‑in‑One)
```bash
# Compile
cd PA8/src
javac *.java

# HashTable mode with small sample
java SpellChecker 0 Samples/tiny.dict.txt Samples/Input1.txt

# BloomFilter mode with larger sample
java SpellChecker 1 Samples/long.dict.txt Samples/Input3.txt
```
